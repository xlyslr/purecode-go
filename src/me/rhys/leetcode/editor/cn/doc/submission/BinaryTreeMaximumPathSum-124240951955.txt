/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
var MaxSum = 0

func maxPathSum(root *TreeNode) int {
	if root == nil {
		return 0
	}
	findOneSideMax(root)
	return MaxSum
}

func findOneSideMax(root *TreeNode) int {
	if root == nil {
		return 0
	}
	leftPathSum := findOneSideMax(root.Left)
	rightPathSum := findOneSideMax(root.Right)
	if leftPathSum < 0 {
		leftPathSum = 0
	}
	if rightPathSum < 0 {
		rightPathSum = 0
	}
	// 第一种场景：left->node->right
	allSum := leftPathSum + rightPathSum + root.Val
	if allSum > MaxSum {
		MaxSum = allSum
	}
	// 第二种场景：经过node的单边分支的最优解。因为leftPathSum/RightPathSum已经处理了负数的场景，所以覆盖了只有当前node的最优解路径场景
	if leftPathSum > rightPathSum {
		return root.Val + leftPathSum
	} else {
		return root.Val + rightPathSum
	}
}


//total_testcases:94
//total_correct:7
//input_formatted:[0]
//expected_output:0
//code_output:42
